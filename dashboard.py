# -*- coding: utf-8 -*-
"""dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zs2A4M_VN7uzUMM6h1Hih6afFFHJbl4E
"""

!pip install dash

"""***This is first heading***"""

import dash
from dash import dcc, html
import plotly.graph_objs as go
import pandas as pd
import numpy as np
import datetime
from dash.dependencies import Input, Output
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler

# Initialize Dash app
app = dash.Dash(__name__)

# Seed for reproducibility
np.random.seed(42)

# Function for generating the dataset
def generate_data(start_date, end_date):
    # Weekly trend (e.g., weekends have higher orders)
    def weekly_trend(day_of_week):
        if day_of_week >= 5:  # Higher orders on weekends (Friday-Sunday)
            return 1.3
        elif day_of_week == 3:  # Midweek slight peak (Thursday)
            return 1.1
        else:
            return 1.0

    # Seasonal effect (e.g., more orders in summer and during holiday months)
    def seasonal_trend(month):
        if month in [12, 1, 2]:  # Winter (holiday season)
            return 1.5
        elif month in [6, 7, 8]:  # Summer
            return 1.3
        else:
            return 1.0

    date_range = pd.date_range(start=start_date, end=end_date, freq='D')
    data = []

    for date in date_range:
        day_of_week = date.weekday()
        month = date.month
        base_order_count = np.random.normal(200, 50)  # Base daily orders with some noise
        order_count = (
            base_order_count
            * weekly_trend(day_of_week)
            * seasonal_trend(month)
            * np.random.normal(1.0, 0.05)  # Adding slight random noise
        )

        data.append({
            "date": date,
            "orders": round(order_count)
        })

    return pd.DataFrame(data)

# Train model to predict the next week's orders
def train_model(df):
    data = df
    # Convert the `date` column to datetime format
    data['date'] = pd.to_datetime(data['date'])

    # Aggregate data by week, summing up the orders
    data.set_index('date', inplace=True)
    weekly_data = data['orders'].resample('W').sum()
    # Scale the `orders` column for better performance with LSTM
    scaler = MinMaxScaler()
    weekly_data = scaler.fit_transform(weekly_data.values.reshape(-1, 1))

    # Prepare sequences for the LSTM model
    def create_sequences(data, seq_length=7):
        sequences = []
        targets = []
        for i in range(len(data) - seq_length):
            sequences.append(data[i:i + seq_length])
            targets.append(data[i + seq_length])
        return np.array(sequences), np.array(targets)

    # Using the weekly `orders` to create input sequences
    seq_length = 4  # Use the past 4 weeks to predict the next week's orders
    X, y = create_sequences(weekly_data, seq_length)
    X
    # Split the data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

    # Reshape data for LSTM input (samples, time steps, features)
    X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))
    X_test = X_test.reshape((X_test.shape[0], X_test.shape[1], 1))

    # Build the LSTM model
    model = Sequential([
        LSTM(64, activation='relu', input_shape=(X_train.shape[1], 1), return_sequences=True),
        Dropout(0.2),
        LSTM(32, activation='relu'),
        Dropout(0.2),
        Dense(1)
    ])

    # Compile the model
    model.compile(optimizer='adam', loss='mse')

    # Early stopping to avoid overfitting
    early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

    # Train the model
    history = model.fit(
        X_train, y_train,
        epochs=500,
        batch_size=16,
        validation_data=(X_test, y_test),
        callbacks=[early_stopping],
        verbose=1
    )

    # Predict the orders for the next week
    next_week_orders_scaled = model.predict(X_test)
    next_week_orders = scaler.inverse_transform(next_week_orders_scaled)

    print("Predicted Orders for Next Week:", next_week_orders)
    # Save model to a file
    with open('model.pkl', 'wb') as file:
        pickle.dump(model, file)
    return model, scaler

# Function to predict the next week's order
def predict_next_week(df, model, scaler):
    # Use the last data point's day_of_week and month as features
    last_day_of_week = df['date'].iloc[-1].weekday()
    last_month = df['date'].iloc[-1].month

    # Prepare the feature vector for the next week's prediction (same day_of_week and month for simplicity)
    X_new = np.array([[last_day_of_week, last_month]])
    X_new_scaled = scaler.transform(X_new)

    # Predict the next week's order
    predicted_order = model.predict(X_new_scaled)[0]
    return predicted_order

# Initial start and end dates for the first data generation
start_date = "2023-01-01"
end_date = "2023-02-01"

# Create the initial data
df = generate_data(start_date, end_date)

# Train the initial model
model, scaler = train_model(df)

# Layout of the dashboard
app.layout = html.Div([
    html.H1("Weekly Orders Dashboard with Predictions"),
    dcc.Graph(id='orders-graph'),
    dcc.Interval(
        id='graph-update',
        interval=1000,  # Update every second (1000 milliseconds)
        n_intervals=0
    )
])

# Callback function to update the graph with animation
@app.callback(
    Output('orders-graph', 'figure'),
    [Input('graph-update', 'n_intervals')]
)
def update_graph(n_intervals):
    global df, model, scaler

    # Predict the next week's order
    predicted_order = predict_next_week(df, model, scaler)

    # Predict the next week's date
    next_week_date = df['date'].max() + pd.Timedelta(days=7)

    # Append the prediction to the data
    predicted_data = pd.DataFrame([{
        "date": next_week_date,
        "orders": round(predicted_order)
    }])

    df = pd.concat([df, predicted_data], ignore_index=True)

    # Only keep the last 5 weeks (35 days of data)
    df = df[df['date'] > df['date'].max() - pd.Timedelta(weeks=5)]

    # Create the plot
    fig = go.Figure()

    # Animation with frames (representing each week)
    frames = []
    for i in range(1, len(df) + 1):
        current_data = df.iloc[:i]
        frames.append(go.Frame(
            data=[go.Scatter(
                x=current_data['date'], y=current_data['orders'],
                mode='lines+markers',
                name='Orders',
                line=dict(color='royalblue'),
                marker=dict(size=6)
            )],
            name=f'Frame {i}'
        ))

    fig.frames = frames

    # Add the initial trace to the graph
    fig.add_trace(go.Scatter(
        x=df['date'], y=df['orders'],
        mode='lines+markers',
        name='Orders',
        line=dict(color='royalblue'),
        marker=dict(size=6)
    ))

    # Set up animation
    fig.update_layout(
        title="Orders for the Past 5 Weeks and Predicted Week",
        xaxis_title="Date",
        yaxis_title="Orders",
        template="plotly_dark",
        updatemenus=[dict(
            type='buttons',
            showactive=False,
            buttons=[dict(
                label='Play',
                method='animate',
                args=[None, dict(frame=dict(duration=1000, redraw=True), fromcurrent=True)]
            )]
        )]
    )

    return fig

# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)

